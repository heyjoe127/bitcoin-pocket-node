package com.pocketnode.oracle

import org.json.JSONArray
import org.json.JSONObject
import org.junit.Assert.*
import org.junit.Test
import kotlin.math.*

/**
 * UTXOracle Parity Test
 *
 * Proves the Kotlin port of UTXOracle v9.1 produces identical results
 * to the original Python implementation by @SteveSimple.
 *
 * Test vectors are generated by tests/gen_vectors.py which runs the Python
 * algorithm (Steps 5-11) against real block data from a Bitcoin node.
 * This test feeds the same filtered outputs to the Kotlin implementation
 * and asserts identical prices at every step.
 *
 * To regenerate vectors:
 *   cd tests && python3 gen_vectors.py
 *   cp oracle_test_vectors.json ../app/src/test/resources/
 */
class UTXOracleParityTest {

    @Test
    fun `Kotlin oracle matches Python oracle exactly`() {
        val json = loadTestVectors()
        val expectedPrice = json.getInt("expected_price")
        val roughPriceExpected = json.getInt("rough_price")
        val outputCountExpected = json.getInt("output_count")

        val rawOutputs = jsonArrayToDoubles(json.getJSONArray("filtered_outputs"))
        val blockHeights = jsonArrayToInts(json.getJSONArray("block_heights"))
        val blockTimes = jsonArrayToLongs(json.getJSONArray("block_times"))

        println("Test vectors: blocks ${json.getJSONArray("block_range")}")
        println("Filtered outputs: ${rawOutputs.size}")

        // ── Step 5: Initialize histogram ─────────────────────────────
        val firstBinValue = -6
        val lastBinValue = 6
        val rangeBinValues = lastBinValue - firstBinValue

        val bins = mutableListOf(0.0)
        for (exp in -6 until 6) {
            for (b in 0 until 200) {
                bins.add(10.0.pow(exp + b / 200.0))
            }
        }
        val numBins = bins.size
        val binCounts = DoubleArray(numBins)

        for (amount in rawOutputs) {
            val amountLog = log10(amount)
            val pctInRange = (amountLog - firstBinValue) / rangeBinValues.toDouble()
            var binEst = (pctInRange * numBins).toInt()
            while (bins[binEst] <= amount) binEst++
            binCounts[binEst - 1] += 1.0
        }

        // ── Step 7: Remove round BTC, normalize, cap ─────────────────
        for (n in 0..200) binCounts[n] = 0.0
        for (n in 1601 until numBins) binCounts[n] = 0.0

        for (r in intArrayOf(201,401,461,496,540,601,661,696,740,
                             801,861,896,940,1001,1061,1096,1140,1201)) {
            binCounts[r] = 0.5 * (binCounts[r + 1] + binCounts[r - 1])
        }

        var curveSum = 0.0
        for (n in 201..1600) curveSum += binCounts[n]
        for (n in 201..1600) {
            binCounts[n] /= curveSum
            if (binCounts[n] > 0.008) binCounts[n] = 0.008
        }

        // ── Step 8: Stencils ─────────────────────────────────────────
        val numElements = 803
        val mean = 411; val stdDev = 201

        val smoothStencil = DoubleArray(numElements) { x ->
            0.00150 * Math.E.pow(-((x - mean).toDouble().pow(2)) / (2.0 * stdDev.toDouble().pow(2))) + 0.0000005 * x
        }

        val spikeStencil = DoubleArray(numElements)
        for ((i, v) in listOf(
            40 to 0.001300198324984352, 141 to 0.001676746949820743,
            201 to 0.003468805546942046, 202 to 0.001991977522512513,
            236 to 0.001905066647961839, 261 to 0.003341772718156079,
            262 to 0.002588902624584287, 296 to 0.002577893841190244,
            297 to 0.002733728814200412, 340 to 0.003076117748975647,
            341 to 0.005613067550103145, 342 to 0.003088253178535568,
            400 to 0.002918457489366139, 401 to 0.006174500465286022,
            402 to 0.004417068070043504, 403 to 0.002628663628020371,
            436 to 0.002858828161543839, 461 to 0.004097463611984264,
            462 to 0.003345917406120509, 496 to 0.002521467726855856,
            497 to 0.002784125730361008, 541 to 0.003792850444811335,
            601 to 0.003688240815848247, 602 to 0.002392400117402263,
            636 to 0.001280993059008106, 661 to 0.001654665137536031,
            662 to 0.001395501347054946, 741 to 0.001154279140906312,
            801 to 0.000832244504868709
        )) { spikeStencil[i] = v }

        // ── Step 9: Rough price ──────────────────────────────────────
        val centerP001 = 601
        val halfStencil = (spikeStencil.size + 1) / 2
        val leftP001 = centerP001 - halfStencil

        var bestSlide = 0; var bestSlideScore = 0.0; var totalScore = 0.0

        for (slide in -141 until 201) {
            var sSmooth = 0.0; var sSco = 0.0
            for (n in 0 until numElements) {
                val cv = binCounts[leftP001 + slide + n]
                sSmooth += cv * smoothStencil[n]; sSco += cv * spikeStencil[n]
            }
            if (slide < 150) sSco += sSmooth * 0.65
            if (sSco > bestSlideScore) { bestSlideScore = sSco; bestSlide = slide }
            totalScore += sSco
        }

        val btcUsdBest = 100.0 / bins[centerP001 + bestSlide]

        var nUpScore = 0.0; var nDownScore = 0.0
        for (n in 0 until numElements) {
            nUpScore += binCounts[leftP001 + bestSlide + 1 + n] * spikeStencil[n]
            nDownScore += binCounts[leftP001 + bestSlide - 1 + n] * spikeStencil[n]
        }

        val bestNeighbor = if (nDownScore > nUpScore) -1 else 1
        val neighborScore = maxOf(nUpScore, nDownScore)
        val btcUsd2nd = 100.0 / bins[centerP001 + bestSlide + bestNeighbor]

        val avgScore = totalScore / (201 - (-141))
        val a1 = bestSlideScore - avgScore; val a2 = abs(neighborScore - avgScore)
        val roughPrice = (a1 / (a1 + a2) * btcUsdBest + a2 / (a1 + a2) * btcUsd2nd).toInt()

        println("Step 9 rough price: Kotlin=\$$roughPrice Python=\$$roughPriceExpected")
        assertEquals("Rough price must match Python exactly", roughPriceExpected, roughPrice)

        // ── Step 10: Intraday price points ───────────────────────────
        val usds = intArrayOf(5,10,15,20,25,30,40,50,100,150,200,300,500,1000)
        val microRemove = mutableListOf<Double>()
        var ii = 0.00005
        while (ii < 0.0001) { microRemove.add(ii); ii += 0.00001 }
        ii = 0.0001; while (ii < 0.001) { microRemove.add(ii); ii += 0.00001 }
        ii = 0.001; while (ii < 0.01) { microRemove.add(ii); ii += 0.0001 }
        ii = 0.01; while (ii < 0.1) { microRemove.add(ii); ii += 0.001 }
        ii = 0.1; while (ii < 1.0) { microRemove.add(ii); ii += 0.01 }

        val outputPrices = mutableListOf<Double>()
        for (i in rawOutputs.indices) {
            val n = rawOutputs[i]
            for (usd in usds) {
                val avbtc = usd.toDouble() / roughPrice
                val up = avbtc * 1.25; val dn = avbtc * 0.75
                if (n > dn && n < up) {
                    var ok = true
                    for (r in microRemove) {
                        if (n > r * 0.9999 && n < r * 1.0001) { ok = false; break }
                    }
                    if (ok) outputPrices.add(usd.toDouble() / n)
                }
            }
        }

        println("Step 10 output count: Kotlin=${outputPrices.size} Python=$outputCountExpected")
        assertEquals("Output count must match Python exactly", outputCountExpected, outputPrices.size)

        // ── Step 11: Exact price via iterative center-finding ────────
        fun findCentral(prices: List<Double>, pMin: Double, pMax: Double): Double {
            val f = prices.filter { it > pMin && it < pMax }.sorted()
            if (f.isEmpty()) return roughPrice.toDouble()
            val ps = DoubleArray(f.size); var t = 0.0
            for (i in f.indices) { t += f[i]; ps[i] = t }
            var md = Double.MAX_VALUE; var bi = 0
            for (i in f.indices) {
                val ls = if (i > 0) ps[i - 1] else 0.0
                val d = (f[i] * i - ls) + (t - ps[i] - f[i] * (f.size - i - 1))
                if (d < md) { md = d; bi = i }
            }
            return f[bi]
        }

        val prt = 0.05
        var cp = findCentral(outputPrices, roughPrice * 0.95, roughPrice * 1.05)
        val avs = mutableSetOf(cp)
        for (iter in 0 until 100) {
            val np = findCentral(outputPrices, cp * (1 - prt), cp * (1 + prt))
            if (np in avs) { cp = np; break }
            avs.add(np); cp = np
        }

        val finalPrice = cp.toInt()

        println("Step 11 final price: Kotlin=\$$finalPrice Python=\$$expectedPrice")
        assertEquals("Final price must match Python exactly", expectedPrice, finalPrice)

        println("\n✅ ALL STEPS MATCH — Kotlin port is faithful to Python original")
    }

    // ── Helpers ──────────────────────────────────────────────────────

    private fun loadTestVectors(): JSONObject {
        val stream = javaClass.classLoader.getResourceAsStream("oracle_test_vectors.json")
            ?: throw AssertionError("oracle_test_vectors.json not found in test resources. Run: cd tests && python3 gen_vectors.py")
        return JSONObject(stream.bufferedReader().readText())
    }

    private fun jsonArrayToDoubles(arr: JSONArray): DoubleArray =
        DoubleArray(arr.length()) { arr.getDouble(it) }

    private fun jsonArrayToInts(arr: JSONArray): IntArray =
        IntArray(arr.length()) { arr.getInt(it) }

    private fun jsonArrayToLongs(arr: JSONArray): LongArray =
        LongArray(arr.length()) { arr.getLong(it) }
}
